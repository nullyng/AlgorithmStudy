# 문제 개요

문제 : [생태학](https://www.acmicpc.net/problem/4358)

문제 분류 : 트라이

# 문제 풀이

두 가지 방법으로 문제를 풀었다.

1. map을 사용해서 풀기
2. 트라이를 사용해서 풀기

입출력은 둘 다 같은 방식을 사용하는데, 입력 시 `getline`을 사용하고  
출력 시 `fixed`와 `precision`을 사용하여 출력할 소수점 자리의 개수를 조정한다.

```cpp
cout << fixed;
cout.precision(4);
```

## 1. map을 사용해서 풀기

입력 받은 문자열을 key, 입력 받은 개수를 value로 map에 저장한다.  
입력과 동시에 전체 나무의 개수도 카운트 한다.

map을 순회하며 나무의 이름과 나무의 개수\*100을 전체 나무 개수에서 나눈 값을 출력한다.

## 2. 트라이를 사용해서 풀기

set과 트라이를 함께 사용한다.  
set에 나무의 이름을 중복없이 저장하고, set을 순회하며 트라이의 `find` 함수로 나무의 개수를 조회한다.

트라이에는 문자의 끝을 나타내는 `finish` 변수 대신, 정수 타입의 `cnt`를 선언한다.  
트라이에 삽입 연산 시 현재 문자가 마지막 문자일 경우 `cnt`를 1 증가시킨다.

또한 **트라이의 자식 노드 배열의 크기는 95로 할당한다.**  
그 이유는 문제에서 입력될 수 있는 문자에 공백과 특수문자가 포함되기 때문이다.  
이걸 못 보고 26으로 할당해서 계속 Segfault 에러가 떴다...^^

즉, 아스키 코드에서 십진수 32의 공백부터 마지막 127까지의 문자가 입력될 수 있다.  
127-32=95이므로 배열의 크기를 95로 할당하고, 삽입이나 찾기 연산 시 현재의 문자에서 `' '`을 뺀 값을 인덱스로 삼는다.

```cpp
// 삽입 연산 중 일부
int curr = *key - ' ';
if(next[curr] == NULL)
  next[curr] = new Trie();
```

📌 **트라이에 삽입하기**  
입력 받은 문자열을 `c_str`을 통해 const char로 변경시킨 후 트라이의 `insert` 함수에 넘겨준다.  
이때 set에도 해당 문자열을 삽입하고, 전체 나무 개수 또한 카운트한다.

📌 **트라이에서 찾기**  
set을 순회하며 나무의 이름을 트라이의 `find` 함수에 넘긴다.  
`find` 함수가 반환한 노드의 `cnt`에 100을 곱한 후 총 나무 개수로 나눈 값을 출력한다.
