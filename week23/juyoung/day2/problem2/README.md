# 문제 개요

문제 : [문자열 지옥에 빠진 호석](https://www.acmicpc.net/problem/20166)

문제 분류 : DFS

# 문제 풀이

핵심은 **map**을 이용하는 것이다.

1. 신이 좋아하는 모든 문자열에 대해 문자열을 key로 하고 0을 value로 하는 값을 map에 등록한다.
2. 모든 칸에 대해 DFS를 수행하는데, 탐색 시작 전에 빈 문자열 `s`에 해당 칸의 문자를 더한다.  
   (해당 칸에 대한 DFS가 끝나면 `s`를 빈 문자열로 초기화한다.)
   1. 현재 `s`의 길이가 5보다 크다면 탐색을 종료한다.  
      (신이 좋아하는 문자열의 길이는 최대 5이므로)
   2. map에 `s`가 존재한다면 해당 값의 value를 1만큼 증가시킨다.
   3. 8방향에 대해 탐색을 수행한다.  
      (이때 격자가 환형임에 주의하여 y, x의 범위를 조정한다.)
   4. 다음 칸의 문자를 `s`에 덧붙이고 재귀적으로 함수를 호출한다.
   5. 재귀함수 호출이 끝난 후에는 덧붙였던 문자를 다시 뺀다.
3. 신이 좋아하는 모든 문자열에 대해 map에서 해당하는 값을 찾아 출력한다.

내가 생각했던 풀이는 모든 케이스를 통과하지 못해서 [다른 사람 풀이](https://ip99202.github.io/posts/%EB%B0%B1%EC%A4%80-20166-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%A7%80%EC%98%A5%EC%97%90-%EB%B9%A0%EC%A7%84-%ED%98%B8%EC%84%9D/)를 참고했다.

### :mag_right: 틀린 풀이

`problem2-fail.cpp`에 작성한 코드는 16개의 데이터 중 2개만 맞혔다고 나왔다.  
이 코드에서는 문제를 아래와 같이 풀이했다.

- 신이 좋아하는 모든 문자열에 대해
  - 이미 map에 해당 문자열이 key로 등록돼있다면 value 출력
  - (0,0)~(N,M)까지 모든 칸에 대해
    - 해당 칸이 현재 문자열의 첫 문자와 같다면 DFS
    - 모든 칸에 대한 탐색이 끝났으면 map에 해당 문자열과 경우의 수를 key, value로 등록

시간초과는 안 났지만 16개 중에서 꼴랑 2개밖에 못 맞히다니...🥲
