# 문제 개요

문제: [계란으로 계란치기](https://www.acmicpc.net/problem/16987)

문제 분류: 백트래킹

# 문제 풀이

각 계란으로 자신을 제외한 계란을 치는 모든 경우에 대해 깨진 계란의 개수가 가장 큰 것을 구한다.

백트래킹의 인자로는 현재 손에 들고 있는 계란의 인덱스를 넘긴다. 인덱스가 `N`과 같아졌을 때 계란 중 내구도가 0 이하인 것의 개수를 카운트하여 현재 정답보다 큰 경우 정답을 업데이트 한다.

만약 현재 손에 들고 있는 계란이 이미 깨진 상태라면 곧바로 다음 계란을 손에 들기 위해 다음 인덱스에 대한 재귀함수를 호출한다. 그렇지 않다면 자기 자신과 이미 깨진 계란을 제외한 모든 계란을 치는데, 어떤 계란을 치고 재귀함수를 호출한 이후에 다음 계란을 쳤을 때의 경우를 계산하기 위해 다시 원래 값으로 돌리는 과정이 필요하다.

```cpp
for (int i = 0; i < N; i++) {
  // 자기 자신이거나 이미 깨진 계란이면 건너뜀
  if(i == idx || egg[i].first <= 0) continue;
  isAllBroken = false;

  // 서로 부딪혀서 내구도 감소
  egg[i].first -= egg[idx].second;
  egg[idx].first -= egg[i].second;

  solution(idx + 1);

  // 다시 원래대로 돌리기
  egg[i].first += egg[idx].second;
  egg[idx].first += egg[i].second;
}
```

이때 `isAllBroken`은 치려는 모든 계란이 이미 깨져있는지 여부를 저장하는 변수이다. 만약 이미 모든 계란이 깨져있다면 재귀함수의 인자로 `N`을 넘겨 현재 경우에 대한 값을 계산할 수 있도록 한다.
