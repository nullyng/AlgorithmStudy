# 문제 개요

문제 : [N으로 표현](https://school.programmers.co.kr/learn/courses/30/lessons/42895)

문제 분류 : 그리디

# 문제 풀이

[다른 사람 풀이](https://velog.io/@euneun/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-N%EC%9C%BC%EB%A1%9C-%ED%91%9C%ED%98%84-DP-%EB%8F%99%EC%A0%81%EA%B3%84%ED%9A%8D%EB%B2%95-C)를 참고했다. 🥲

`i`개의 `N`으로 만들 수 있는 숫자에는 크게 아래의 두 가지가 있다.

1. **`N`을 `i`개만큼 이어붙인 수**
   - 55, 555, ...
2. **`a`개의 `N`으로 만들 수 있는 수 op `b`개의 `N`으로 만들 수 있는 수**
   - 만약 `N`이 5이고 `i`가 2라면
     - 1개의 5로 만들 수 있는 수 + 1개의 5로 만들 수 있는 수
     - 1개의 5로 만들 수 있는 수 \* 1개의 5로 만들 수 있는 수
     - ...
   - 만약 `N`이 5이고 `i`가 3라면
     - 1개의 5로 만들 수 있는 수 + 2개의 5로 만들 수 있는 수
     - 1개의 5로 만들 수 있는 수 \* 2개의 5로 만들 수 있는 수
     - ...
     - 2개의 5로 만들 수 있는 수 + 1개의 5로 만들 수 있는 수
     - 2개의 5로 만들 수 있는 수 \* 1개의 5로 만들 수 있는 수
     - ...

이때 2번의 경우에서 dp를 사용한다.  
즉, `dp[i]+dp[j]`, `dp[i]-dp[j]`, `dp[i]*dp[j]`, `dp[i]/dp[j]` (이때 `i+j=k`)

- **`dp[i]` : `i`개의 `N`으로 만들 수 있는 숫자들**

문제의 조건과 위의 `dp` 정의에 의해 `dp` 배열의 길이는 8로도 충분하다.  
각 `dp[i]`에는 중복을 허용하지 않는 set을 선언하여 각 수를 저장한다.

위 내용으로 `dp`를 채워나가면서 set에서 `number`에 해당하는 수가 있다면, 곧바로 현재 인덱스를 반환한다.  
`dp` 배열을 모두 채울 때까지 `number`가 set에 존재하지 않는다면 -1을 반환한다.
