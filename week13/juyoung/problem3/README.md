# 문제 개요

문제 : [등굣길](https://school.programmers.co.kr/learn/courses/30/lessons/42898)

문제 분류 : DP

# 문제 풀이

- **`dp[i][j]`: 해당 위치로 오는 경로의 개수**

문제에서는 최단 경로의 개수라고 말했지만, 오른쪽과 아래로 밖에 이동할 수 없다면 모든 경로가 최단 경로가 된다.  
즉 오른쪽과 아래로 이동하는 모든 경로의 개수를 구하면 된다.

🚦 이 문제에서 주의할 점 두 가지!

1. 1,000,000,007로 나눈 나머지를 return 해야 한다는 점
2. 행과 열이 바뀌어서 주어진다는 점

문제에서는 행과 열이 바뀌어서 (열, 행)의 형태로 주어진다.  
물이 잠긴 지역에 해당하는 `puddles`의 원소도 [열, 행]의 형태로 주어지므로 주의해야 한다.

문제는 아래의 순서로 풀이했다.

### 1. `dp` 배열 초기화

- 물에 잠긴 지역을 -1로 초기화
- 집을 제외하고, 1행 1열을 전부 1로 초기화
  - 이때 물에 잠긴 지역을 만나면 그대로 break (이후의 위치들은 갈 수 있는 경로가 0개이므로)

오른쪽과 아래로 밖에 이동할 수 없으므로 1행 1열의 모든 위치는 갈 수 있는 경로가 1개뿐이다.

### 2. `dp` 배열 채우기

(2, 2)부터 `dp` 배열을 채우기 시작한다.

- 현재 위치가 물에 잠긴 지역이라면 건너뛴다.
- 위 칸이나 왼쪽 칸 중 물에 잠긴 지역이 있다면 물에 잠기지 않은 지역의 경로 개수를 `dp[i][j]`에 저장한다.
- 위 칸, 왼쪽 칸 모두 물에 잠겨있다면 `dp[i][j]`에 0을 저장한다.
- 위 조건들을 전부 만족하지 않는다면 위 칸과 왼쪽 칸의 경로 합을 `dp[i][j]`에 저장한다.

위 칸과 왼쪽 칸을 참조하는 이유는 현재 위치로 올 수 있는 방법이 위 칸에서 아래로 내려오거나 왼쪽 칸에서 오른쪽으로 이동하는 것뿐이기 때문이다.

마지막으로 `dp[n][m]`을 반환한다.

![IMG_A96A956959B6-1](https://user-images.githubusercontent.com/57346428/220557789-54a8f338-378b-4304-a9ec-a72b3bbce18e.jpeg)
(`n`=3, `m`=4, 물에 잠긴 지역이 없는 경우와 있는 경우 각각의 `dp` 배열)
