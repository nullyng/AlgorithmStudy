# 문제 개요

문제: [마라톤 2](https://www.acmicpc.net/problem/10653)

문제 분류: DP

# 문제 풀이

DP는 진짜 어려운 것 같다... [다른 사람 코드](https://xkdlaldfjtnl.tistory.com/98)와 [풀이](https://velog.io/@cgw0519/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4-%EB%B0%B1%EC%A4%80-10653-%EB%A7%88%EB%9D%BC%ED%86%A4-2)를 참고했다.

- **`dp[i][j]` : i번째 체크포인트에 도착했을 때 그전까지 j개만큼 건너뛴 경우의 최소 거리**

먼저 미리 좌표 간의 거리를 계산하여 `dist` 배열에 저장한다. 이후 재귀함수를 통해 `dp` 배열을 채워나간다. 아래는 재귀함수의 코드 일부이다.

```cpp
int min_dist = 2e9;
for (int i = 0; i <= k; i++) {
  if(p-i-1 < 1) break;
  min_dist = min(solve(p - i - 1, k - i) + dist[p - i - 1][p], min_dist);
}
```

`p`는 현재 위치이며, 0개를 건너뛰었을 때부터 `k`개를 건너뛰었을 때까지 각각의 최소 거리를 계산한다.

`p-i-1 < 1`인 경우 break 하는 이유는 있을 수 없는 경우를 건너뛰기 위해서이다. 예를 들어 2번 체크포인트에 도착했는데(`p=2`) 이미 1번 건너뛴 경우(`i=1`)는 있을 수 없다. 이런 경우에는 계산하지 않고 건너뛴다.

`min_dist`는 아래 두 가지를 비교하여 더 작은 값으로 갱신한다.

1. `p-i-1`번 체크포인트에 도착했을 때 그전까지 `k-i`개만큼 건너뛴 경우의 최소 거리 + `p-i-1`에서 `p`까지 건너뛴 경우의 거리

   - ex) `solve(3, 2)+dist[3][4]`  
     = 2번 건너뛰어서 3번 체크포인트로 갔을 때의 최소 거리 + 3번에서 4번까지의 거리

2. 현재의 최소 거리

위 계산을 통해 나온 값들 중 가장 작은 값을 `dp` 배열에 저장한다.
