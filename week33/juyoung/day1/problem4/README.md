# 문제 개요

문제: [벽 부수고 이동하기 2](https://www.acmicpc.net/problem/14442)

문제 분류: BFS

# 문제 풀이

[다른 사람 풀이](https://yabmoons.tistory.com/39)를 참고했다.

(1,1)부터 BFS를 수행하는데 이때 큐에 `{y, x, 경로의 길이, 부순 벽의 개수}`를 push하며 진행한다.

또한 각 위치의 방문 여부와 해당 위치에 오기까지 벽을 `w`개 부순 적이 있음을 표시하는 3차원 `visited` 배열을 사용한다.

만약 현재 위치가 벽이 아니라면 벽을 부수는 것 없이 다음 위치로 이동하고

```cpp
visited[ny][nx][w] = true;
q.push({ny, nx, d + 1, w});
```

현재 위치가 벽이고 현재까지 부순 벽의 개수가 `K`개보다 적다면 벽을 부수고 다음 위치로 이동한다.

```cpp
visited[ny][nx][w + 1] = true;
q.push({ny, nx, d + 1, w + 1});
```

(N,M)에 도착하면 큐에서 꺼낸 경로의 길이를 출력한다.
