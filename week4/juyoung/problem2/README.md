# 문제 개요

문제 : [Moo 게임](https://www.acmicpc.net/problem/5904)

문제 분류 : 분할정복

# 문제 풀이

메모리 초과가 나서 이전 풀이를 참고했다. 🥲

Moo 수열 S(k)는 세 가지 부분으로 나눌 수 있다.

1. S(k-1)
2. o가 k+2개인 수열
3. S(k-1)

`N`번째 글자는 **길이가 `N` 이상인 Moo 수열 중 가장 짧은 Moo 수열의 세 가지 부분 중 하나에 속해있다.**  
직접 Moo 수열을 구할 수도 있겠지만, `N`의 범위가 크기 때문에 전체 Moo 수열을 변수에 담을 수 없거나 많은 재귀적 호출로 인해 메모리 초과가 발생한다.

따라서 길이를 구하고, 이를 바탕으로 `N`번째 글자를 구한다.  
우선, 길이가 `N` 이상인 Moo 수열 중 가장 짧은 Moo 수열의 길이 `len`을 구한다.  
더불어 해당 수열에서 o가 k+2개인 수열의 길이 `temp` 또한 구한다.  
이때 `temp`의 초기값은 3이다. Moo 수열의 시작이 `moo`이기 때문이다.

```cpp
while(1) {
  len = len * 2 + temp;
  if (len >= N) break;
  temp++;
}
```

위에서 세 부분으로 나눈 Moo 수열 중, `N`번째 글자가 어디에 속하는지 알기 위해 이전 문자열의 길이 `prev`를 구한다.

그리고 `N`이 2번째 수열에 속할 때까지 아래를 반복한다.

1. **`N`이 2번째 수열(=o가 k+2개인 수열)에 속한다면**

   - 가장 첫번째 원소만 'm'이고 나머지는 전부 'o'
   - `N-prev`가 1일 때 'm', 1이 아닐 때 'o'를 출력하고 종료

2. **`N`이 1, 3번째 수열(=S(k-1))에 속한다면**

   - 전체 수열의 길이 `len`와 2번째 수열의 길이 `temp` 조정
   - `N`이 1번째 수열에 속한다면 `len`을 이전 문자열의 길이 `prev`로 수정, `temp`를 1만큼 감소
   - `N`이 3번째 수열에 속할 때도 마찬가지이지만, 이때는 앞쪽의 수열들이 빠지기 때문에 `N`에서 그만큼의 길이를 빼줘야 한다.
